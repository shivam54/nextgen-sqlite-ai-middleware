/*
 * Neural Network Scoring for SQLite Cache
 * 2-layer network: 4 inputs → 8 hidden → 1 output
 * 
 * This file provides ML-based page scoring for cache eviction decisions
 */

#include <math.h>
#include <stdint.h>

typedef unsigned int u32;
typedef unsigned char u8;

// Include weights (generated by train_simple_nn.py)
#include "nn_weights.h"

// Sigmoid activation function
static float sigmoid(float x) {
    // Clamp to prevent overflow
    if (x > 500.0f) return 1.0f;
    if (x < -500.0f) return 0.0f;
    return 1.0f / (1.0f + expf(-x));
}

/*
 * Score a page using neural network
 * 
 * Parameters:
 *   access_count: Number of times page was accessed
 *   time_since: Milliseconds since last access
 *   is_dirty: 1 if page is dirty, 0 if clean
 *   has_refs: 1 if page has active references, 0 otherwise
 * 
 * Returns:
 *   Score between 0.0 (evict) and 1.0 (keep)
 */
float scorePageWithNN(u32 access_count, u32 time_since, u8 is_dirty, u8 has_refs) {
    // Normalize input features (same as training)
    float x[4] = {
        (float)access_count / 100.0f,   // Normalize access count
        (float)time_since / 1000.0f,    // Normalize time (ms to seconds)
        (float)is_dirty,                 // Already 0 or 1
        (float)has_refs                 // Already 0 or 1
    };
    
    // Hidden layer: 4 inputs → 8 neurons
    float hidden[8];
    for (int i = 0; i < 8; i++) {
        float sum = b1[i];  // Bias
        for (int j = 0; j < 4; j++) {
            sum += x[j] * W1[j][i];  // Weighted sum
        }
        hidden[i] = sigmoid(sum);  // Activation
    }
    
    // Output layer: 8 hidden → 1 output
    float output = b2[0];  // Bias
    for (int i = 0; i < 8; i++) {
        output += hidden[i] * W2[i][0];  // Weighted sum
    }
    output = sigmoid(output);  // Final activation
    
    return output;  // Return score: 0.0 = evict, 1.0 = keep
}

/*
 * Get access count for a page
 */
static u32 getAccessCount(void *pPage) {
    
    return 1; 
}

/*
 * Get time since last access in milliseconds
 */
static u32 getTimeSinceAccess(void *pPage) {
     return 100;  
}

/*
 * Wrapper function to score a page from PgHdr1 structure
 */
float scorePageFromPgHdr(void *pPage, u8 is_dirty, u8 has_refs) {
    u32 access_count = getAccessCount(pPage);
    u32 time_since = getTimeSinceAccess(pPage);
    
    return scorePageWithNN(access_count, time_since, is_dirty, has_refs);
}

